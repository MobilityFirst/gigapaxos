# Primary Backup Manager

Primary Backup Manager (`PrimaryBackupManager`) is a manager for Primary Backup 
Replica Coordinator used in Gigapaxos. The `PrimaryBackupManager` uses Paxos to 
agree on the order of StateDiff and primary changes, in all the Nodes.

## TODO
- [ ] Consistently use `App` or `Service`. Currently, both terms are used 
      interchangeably, potential confusion for contributing developers. 
- [ ] Implement `CoordinatorMultiplexer` in XDN.

## Request Encapsulation

There are one main packet types that `PrimaryBackupManager` can handle: 
`PrimaryBackupPacket`.

The coordinator, `PrimaryBackupReplicaCoordinator`, offloads the coordination
to the `PrimaryBackupManager`. The coordinator handles two request/packet types:
`ReplicableClientRequest` and `PrimaryBackupPacket`. Other request/packet types
will cause runtime exception, and thus will be ignored.

`ReplicableClientRequest` encapsulates AppRequest coming from the end user.
For example, in the `MonotonicApp`, `MonotonicAppRequest` is the AppRequest,
it implements `ClientRequest` interface so the Application (i.e., `MonotonicApp`) 
and `PrimaryBackupManager` can pass the response, generated by the Application.

Because `PrimaryBackupManager` can only handle `PrimaryBackupPacket`, when the 
coordinator receives `ReplicableClientRequest`, a specific request coming from end 
user, the coordinator will unwrap the encapsulated AppRequest and re-encapsulate 
the AppRequest inside `RequestPacket`, an inheritance of `PrimaryBackupPacket`. 
This re-encapsulation is illustrated in the figure below, the process happens 
in the `coordinateRequest(.)` method in the `PrimaryBackupReplicaCoordinator`.

```
┌─────────────────────────┐          ┌────────────────┐
│ReplicableClientRequest  │          │RequestPacket   │
│ ┌───────────────────────┤   ───►   │  ┌─────────────┤
│ │AppRequest             │          │  │AppRequest   │
└─┴───────────────────────┘          └──┴─────────────┘
```
Other instances of `PrimaryBackupPacket` include `ApplyStateDiffPacket`, 
`StartEpochPacket` and others specified in the `PrimaryBackupPacketType`
at the `packets` directory.

> Note: The use of `ReplicableClientRequest` mainly because of the same 
approach used in other replica coordinator (e.g., Gigapaxos). We might 
remove it in the future so `PrimaryBackupReplicaCoordinator` exclusively 
only handle `PrimaryBackupPacket`, and not other kind of request/packet.

In general, `PrimaryBackupPacket` is exclusively handled in the coordination 
layer, while AppRequest is exclusively handled in the Application layer, 
below coordination layer. 

## Request Execution

## Primary Backup Over Shared Paxos Logging Library

Assumption about the underlying Paxos Logging Library:
- The library implements MultiPaxos, agreement over multiple values in a sequential log.
- The library provides interface to `propose(Value)`
- Once a proposed `Value` is decided, the library will notify the library's user: the Primary Backup Manager.
- `Notify(Value)`: Notifications of the agreed upon `Values` comes in-order of the `Value` in the log.
- The library runs in the same Node as the Node for the Primary Backup Manager, eliminating network round-trip for 
  the library's user to access the library.
- The library provides `isCoordinator()` that hint whether the current node is the Paxos' coordinator or not.

There are three possible roles for the Node:
- `PRIMARY_CANDIDATE`
- `PRIMARY`
- `BACKUP`

Each instance of Primary has unique Epoch (i.e., PrimaryEpoch), created from the pair of a counter and Node's ID 
(e.g., `101:node1`, `101` is the counter and `node1` is the Node ID, used to break the tie between Epoch with the same 
counter). Epoch in Primary Backup is similar with Ballot in MultiPaxos. 
All Nodes start with the `BACKUP` role.
Important state stored in each node:
- `myNodeID`
- `currentRole`
- `currentPrimaryEpoch`
- `pendingRequests`: list of requests when the Node is still in the `PRIMARY_CANDIDATE` role.

Upon startup (i.e., replica group creation):
```
- currentRole <- `BACKUP`
- If isCoordinator():
     zeroPrimaryEpoch <- {0, myNodeID}
     propose(StartPrimaryEpoch{zeroPrimaryEpoch})
     currentRole <- `PRIMARY_CANDIDATE`
```

Upon receiving `Notify(StartPrimaryEpoch{e})`:
```
- If e < currentPrimaryEpoch:
-    do nothing, return.
-
- currentPrimaryEpoch <- e
- If isMyNodeEpoch(e):
     currentRole <- `PRIMARY`
     for r in pendingRequests:
         app.execute(r)
     stateDiff <- app.captureStateDiff()
     propose(ApplyStateDiff{currentPrimaryEpoch, stateDiff})

```

Upon receiving Request `r` from client:
```
- If currentRole = `BACKUP`:
     forward r to PRIMARY, if known.
     return
- If currentRole = `PRIMARY_CANDIDATE`:
     pendingRequests.put(r)
     return
- If currentRole = `PRIMARY`:
     app.execute(r)
     stateDiff <- app.captureStateDiff()
     propose(ApplyStateDiff{currentPrimaryEpoch, stateDiff})
```

Upon receiving `Notify(ApplyStateDiff{primaryEpoch, stateDiff})`:
```
- If primaryEpoch < currentPrimaryEpoch: // stateDiff becomes no-op
-    do nothing, return.
- If isMyEpoch(primaryEpoch):            // ignoring stateDiff generated by me 
-    do nothing, return
- currentPrimaryEpoch <- primaryEpoch
- app.applyStateDiff(stateDiff);
```