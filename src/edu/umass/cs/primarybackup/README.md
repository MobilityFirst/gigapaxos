# Primary Backup Manager

Primary Backup Manager (`PrimaryBackupManager`) is a manager for Primary Backup 
Replica Coordinator used in Gigapaxos. The `PrimaryBackupManager` uses Paxos to 
agree on the order of StateDiff and primary changes, in all the Nodes.

## TODO
- [ ] Consistently use `App` or `Service`. Currently, both terms are used 
      interchangeably, potential confusion for contributing developers. 
- [ ] Implement `CoordinatorMultiplexer` in XDN.

## Request Encapsulation

There are one main packet types that `PrimaryBackupManager` can handle: 
`PrimaryBackupPacket`.

The coordinator, `PrimaryBackupReplicaCoordinator`, offloads the coordination
to the `PrimaryBackupManager`. The coordinator handles two request/packet types:
`ReplicableClientRequest` and `PrimaryBackupPacket`. Other request/packet types
will cause runtime exception, and thus will be ignored.

`ReplicableClientRequest` encapsulates AppRequest coming from the end user.
For example, in the `MonotonicApp`, `MonotonicAppRequest` is the AppRequest,
it implements `ClientRequest` interface so the Application (i.e., `MonotonicApp`) 
and `PrimaryBackupManager` can pass the response, generated by the Application.

Because `PrimaryBackupManager` can only handle `PrimaryBackupPacket`, when the 
coordinator receives `ReplicableClientRequest`, a specific request coming from end 
user, the coordinator will unwrap the encapsulated AppRequest and re-encapsulate 
the AppRequest inside `RequestPacket`, an inheritance of `PrimaryBackupPacket`. 
This re-encapsulation is illustrated in the figure below, the process happens 
in the `coordinateRequest(.)` method in the `PrimaryBackupReplicaCoordinator`.

```
┌─────────────────────────┐          ┌────────────────┐
│ReplicableClientRequest  │          │RequestPacket   │
│ ┌───────────────────────┤   ───►   │  ┌─────────────┤
│ │AppRequest             │          │  │AppRequest   │
└─┴───────────────────────┘          └──┴─────────────┘
```
Other instances of `PrimaryBackupPacket` include `ApplyStateDiffPacket`, 
`StartEpochPacket` and others specified in the `PrimaryBackupPacketType`
at the `packets` directory.

> Note: The use of `ReplicableClientRequest` mainly because of the same 
approach used in other replica coordinator (e.g., Gigapaxos). We might 
remove it in the future so `PrimaryBackupReplicaCoordinator` exclusively 
only handle `PrimaryBackupPacket`, and not other kind of request/packet.

In general, `PrimaryBackupPacket` is exclusively handled in the coordination 
layer, while AppRequest is exclusively handled in the Application layer, 
below coordination layer. 

## Request Execution

## Primary Backup Over Shared Paxos Logging Library

Assumption about the underlying Paxos Logging Library:
- The library implements MultiPaxos, agreement over multiple values in a sequential log.
- The library provides interface to `propose_i(Value)`
- Once a proposed `Value` is (executed), the library will notify the proposer `i`: the Primary Backup Manager.
- `Execute(Value)`: Notifications of the agreed upon `Values` comes in-order of the `Value` in the log.
- The library runs in the same Node as the Node for the Primary Backup Manager, eliminating network round-trip for 
  the library's user to access the library.
- The library provides `isCoordinator()` that hint whether the current node is the Paxos' coordinator or not.
- The library provides `restartFromLastCheckpoint()` that resending all the `Execute(Value)` received so far. 

Assumption about the application `app` that run over Primary Backup:
- `app.execute(r)`: atomically executing a request, which potentially changing the underlying application's state.
- `app.captureStateDiff()`: returning the state diff after the latest call of `captureStateDiff()`. This interface 
  can also be called after executing a batch of requests to capture the state diff after all those requests.
- `app.applyStateDiff(s)`: applying state diff `s` generated by the primary. `s` is applied over application's 
   current state. 
- `app.reset()`: reset the application state.

There are three possible roles for the Node:
- `PRIMARY_CANDIDATE`
- `PRIMARY`
- `BACKUP`

Each instance of Primary has unique Epoch (i.e., PrimaryEpoch), created from the pair of a counter and Node's ID 
(e.g., `101:node1`, `101` is the counter and `node1` is the Node ID, used to break the tie between Epoch with the same 
counter). Epoch in Primary Backup is similar with Ballot in MultiPaxos. 
All Nodes start with the `BACKUP` role.
Important state stored in each node:
- `myNodeID`
- `currentRole`
- `currentPrimaryEpoch`
- `pendingRequests`: list of requests when the Node is still in the `PRIMARY_CANDIDATE` role.

Upon startup (i.e., replica group creation):
```
- currentRole <- `BACKUP`
- currentPrimaryEpoch <- {0, null}
- pendingRequests <- null
- If isCoordinator():
     zeroPrimaryEpoch <- {0, myNodeID}
     propose(StartPrimaryEpoch{zeroPrimaryEpoch})
     currentRole <- `PRIMARY_CANDIDATE`
```

Upon receiving `Notify(StartPrimaryEpoch{e})`:
```
- If e < currentPrimaryEpoch:       // stale start-epoch becomes no-op
-    do nothing, return.
- 
- If currentRole == `PRIMARY`:      // old-primary steps down
-    currentRole <- `BACKUP`.
-    app.reset()
-    restartFromLastCheckpoint()
-    return
- 
- currentPrimaryEpoch <- e          // TODO: need to be moved?
- If isMyNodeEpoch(e):              // primary-candidate becomes primary
     currentRole <- `PRIMARY`
     for r in pendingRequests:
         app.execute(r)
     stateDiff <- app.captureStateDiff()
     propose(ApplyStateDiff{currentPrimaryEpoch, stateDiff})

```

Upon receiving Request `r` from client:
```
- If currentRole = `BACKUP`:
     forward r to PRIMARY, if known.        // TODO: specify the primary node
     return
- If currentRole = `PRIMARY_CANDIDATE`:
     pendingRequests.put(r)
     return
- If currentRole = `PRIMARY`:
     app.execute(r)
     stateDiff <- app.captureStateDiff()
     propose(ApplyStateDiff{currentPrimaryEpoch, stateDiff})
```

Upon receiving `Notify(ApplyStateDiff{primaryEpoch, stateDiff})`:
```
- If primaryEpoch < currentPrimaryEpoch: // stateDiff becomes no-op
-    do nothing, return.
- If isMyEpoch(primaryEpoch):            // ignoring stateDiff generated by me 
-    do nothing, return
- currentPrimaryEpoch <- primaryEpoch
- app.applyStateDiff(stateDiff);
```

Notes on optimizations:
- The Primary and Paxos' coordinator generally does not have to be the same node. 
  However, having them as the same node reduces message hops, resulting in lower latency.
- To co-locate the Primary and Paxos' coordinator, the Paxos library needs to provide
  `beCoordinator()` method that make the current node as the Paxos' coordinator, with high
  probability. The Primary node will periodically check Paxos' `isCoordinator()` and 
  call `beCoordinator(), if needed, to ensure both Primary and Paxos' coordinator
  are at the same node, most of the time.
- External user can specify which node need to be the Primary, and in turn need to be
  Paxos' coordinator.